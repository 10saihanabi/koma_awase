<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ÈßíÂêà„Çè„Åõ by „ÅØ„Å™„Å≥</title>
    <style>
        body { background: #222; color: white; text-align: center; font-family: "Sawarabi Mincho", serif; margin: 0; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; }
        .ui-container { margin-top: 10px; margin-bottom: 5px; z-index: 10; }
        .title { font-size: 1.4rem; margin-bottom: 5px; }
        .title a { color: #1DA1F2; text-decoration: none; font-size: 0.9rem; margin-left: 10px; }
        .status { font-size: 1.1rem; background: rgba(50, 30, 10, 0.8); display: inline-block; padding: 5px 20px; border-radius: 20px; border: 1px solid #d4a373; }
        #timer { position: absolute; top: 10px; left: 10px; font-size: 1.5rem; color: #fff; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 5px; font-family: monospace; }
        canvas { border: none; box-shadow: 0 0 30px rgba(0,0,0,0.7); cursor: none; touch-action: none; background: #111; }
    </style>
</head>
<body>
    <div id="timer">00.00</div>
    <div class="ui-container">
        <div class="title">ÈßíÂêà„Çè„Åõ <small>by <a href="https://x.com/hanabi7711" target="_blank">„ÅØ„Å™„Å≥ (@hanabi7711)</a></small></div>
        <div class="status" id="status">ÂÆâÁΩÆ„ÅÆ„ÄåÊ≠©„Äç„ÇíÊé¥„Çì„Åß„Çπ„Çø„Éº„ÉàÔºÅ</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const timerEl = document.getElementById('timer');

        canvas.width = 600; canvas.height = 600;
        const CW = canvas.width; const CH = canvas.height;
        const CX = CW / 2; const CY = CH / 2;

        const RANKS = ["Ê≠©", "È¶ô", "Ê°Ç", "ÈäÄ", "Èáë", "Ëßí", "È£õ", "Áéã"];
        const WIN_MSGS = [{l1: "„ÅäÂâç„Å´„ÅØÊ•Ω„Åô„Åé„ÇãÂ∞ÜÊ£ã„Åò„ÇÉ„Å£„Åü„Å™", l2: "You Win!"}, {l1: "Â§©ÊâçÁöÑ„Å™Èßí„Åï„Å∞„Åç„Åò„ÇÉ", l2: "Perfect Victory!"}];
        const LOSE_MSGS = [{l1: "You lose", l2: ""}];

        let pieces = []; let bombs = [];
        let attachedPiece = null;
        let isGameOver = false; let isClear = false;
        let mouseX = CX, mouseY = CY;
        let speedMultiplier = 1.0;
        let currentBoardSize = 560;
        let startTime = null;
        let elapsedTime = "00.00";
        let finalMsg = null;
        const SAFE_ZONE_SIZE = 100;

        class GameObject {
            constructor(x, y, radius, mass) {
                this.x = x; this.y = y; this.radius = radius; this.mass = mass;
                this.vx = 0; this.vy = 0;
            }
            checkWall(size) {
                const half = size / 2;
                const left = CX - half + this.radius; const right = CX + half - this.radius;
                const top = CY - half + this.radius; const bottom = CY + half - this.radius;
                if (this.x < left) { this.x = left; this.vx = Math.abs(this.vx); }
                else if (this.x > right) { this.x = right; this.vx = -Math.abs(this.vx); }
                if (this.y < top) { this.y = top; this.vy = Math.abs(this.vy); }
                else if (this.y > bottom) { this.y = bottom; this.vy = -Math.abs(this.vy); }
            }
            checkSafeZone(size) {
                const half = size / 2;
                const bX = CX - half; const bY = CY - half;
                if (this.x < bX + SAFE_ZONE_SIZE + this.radius && this.y > bY + size - SAFE_ZONE_SIZE - this.radius) {
                    if (this.vx < 0) this.vx = Math.abs(this.vx);
                    if (this.vy > 0) this.vy = -Math.abs(this.vy);
                }
            }
        }

        class Piece extends GameObject {
            constructor(x, y, rank, isFixed = false) {
                super(x, y, 22 + rank * 2, 1 + rank * 0.5);
                this.rank = rank; this.isFixed = isFixed; this.angle = 0;
                this.rotSpeed = (Math.random() - 0.5) * 0.08;
                if (!isFixed) this.initMovement();
            }
            initMovement() {
                const b = 1.5;
                this.vx = (Math.random() - 0.5) * b; this.vy = (Math.random() - 0.5) * b;
            }
            update() {
                if (this === attachedPiece) {
                    this.x += (mouseX - this.x) * 0.25; this.y += (mouseY - this.y) * 0.25; this.angle += 0.1;
                } else if (!this.isFixed) {
                    this.x += this.vx * speedMultiplier; this.y += this.vy * speedMultiplier;
                    this.angle += this.rotSpeed * speedMultiplier;
                    this.checkWall(currentBoardSize); this.checkSafeZone(currentBoardSize);
                }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.beginPath(); ctx.moveTo(0, -this.radius);
                ctx.lineTo(this.radius * 0.8, -this.radius * 0.2); ctx.lineTo(this.radius * 0.7, this.radius);
                ctx.lineTo(-this.radius * 0.7, this.radius); ctx.lineTo(-this.radius * 0.8, -this.radius * 0.2); ctx.closePath();
                ctx.fillStyle = (this === attachedPiece) ? "#fff0d0" : "#fce2c4"; ctx.fill();
                ctx.strokeStyle = (this === attachedPiece) ? "#ff4400" : "#5d3e21"; ctx.lineWidth = 3; ctx.stroke();
                ctx.fillStyle = "#222"; ctx.font = `bold ${this.radius * 0.9}px serif`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(RANKS[this.rank], 0, 5); ctx.restore();
            }
        }

        class Bomb extends GameObject {
            constructor(x, y) {
                super(x, y, 16, 2);
                const b = 3.5;
                this.vx = (Math.random() - 0.5) * b; this.vy = (Math.random() - 0.5) * b;
                this.invincibleTimer = 0.2;
            }
            update(dt) {
                if (this.invincibleTimer > 0) this.invincibleTimer -= dt;
                this.x += this.vx * speedMultiplier; this.y += this.vy * speedMultiplier;
                this.checkWall(currentBoardSize); this.checkSafeZone(currentBoardSize);
            }
            draw() {
                ctx.save();
                if (this.invincibleTimer > 0) ctx.globalAlpha = 0.4;
                ctx.font = "32px serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText("üí£", this.x, this.y);
                ctx.restore();
            }
        }

        function resolveCollision(obj1, obj2) {
            const dx = obj2.x - obj1.x; const dy = obj2.y - obj1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = obj1.radius + obj2.radius;
            if (distance < minDistance && distance > 0) {
                const nx = dx / distance; const ny = dy / distance;
                const overlap = minDistance - distance;
                if (obj1 !== attachedPiece) { obj1.x -= nx * (overlap / 2); obj1.y -= ny * (overlap / 2); }
                if (obj2 !== attachedPiece) { obj2.x += nx * (overlap / 2); obj2.y += ny * (overlap / 2); }
                const vRelativeX = obj1.vx - obj2.vx; const vRelativeY = obj1.vy - obj2.vy;
                const velocityAlongNormal = vRelativeX * nx + vRelativeY * ny;
                if (velocityAlongNormal > 0) {
                    const restitution = 1.0;
                    const j = -(1 + restitution) * velocityAlongNormal / (1/obj1.mass + 1/obj2.mass);
                    const impulseX = j * nx; const impulseY = j * ny;
                    if (obj1 !== attachedPiece) { obj1.vx += impulseX / obj1.mass; obj1.vy += impulseY / obj1.mass; }
                    if (obj2 !== attachedPiece) { obj2.vx -= impulseX / obj2.mass; obj2.vy -= impulseY / obj2.mass; }
                }
                return true;
            }
            return false;
        }

        function mergePieces(p1, p2) {
            const nextRank = p1.rank + 1; const nx = p1.x; const ny = p1.y;
            pieces = pieces.filter(p => p !== p1 && p !== p2);
            const newP = new Piece(nx, ny, nextRank);
            pieces.push(newP); attachedPiece = newP;
            speedMultiplier = Math.min(5.0, speedMultiplier + 0.5);
            bombs.push(new Bomb(CX, CY));
            currentBoardSize = Math.max(350, currentBoardSize - 15);
            statusEl.innerText = `${RANKS[nextRank]}! Âä†ÈÄüx${speedMultiplier.toFixed(1)}`;
            if (RANKS[nextRank] === "Áéã") isClear = true;
            return true;
        }

        let lastTime = Date.now();
        function gameLoop() {
            if (isGameOver || isClear) { drawScene(); return; }
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if (startTime) {
                elapsedTime = ((now - startTime) / 1000).toFixed(2);
                timerEl.innerText = elapsedTime;
            }

            pieces.forEach(p => p.update());
            bombs.forEach(b => b.update(dt));

            for (let i = 0; i < pieces.length; i++) {
                for (let j = i + 1; j < pieces.length; j++) {
                    const p1 = pieces[i]; const p2 = pieces[j];
                    if (Math.hypot(p2.x - p1.x, p2.y - p1.y) < p1.radius + p2.radius) {
                        if (p1 === attachedPiece || p2 === attachedPiece) {
                            const other = (p1 === attachedPiece) ? p2 : p1;
                            if (other.rank === attachedPiece.rank) {
                                mergePieces(p1, p2); return requestAnimationFrame(gameLoop);
                            } else { isGameOver = true; }
                        } else { resolveCollision(p1, p2); }
                    }
                }
            }

            for (let p of pieces) {
                for (let b of bombs) {
                    if (Math.hypot(b.x - p.x, b.y - p.y) < p.radius + b.radius) {
                        if (p === attachedPiece) {
                            if (b.invincibleTimer <= 0) isGameOver = true;
                        } else resolveCollision(p, b);
                    }
                }
            }

            for (let i = 0; i < bombs.length; i++) {
                for (let j = i + 1; j < bombs.length; j++) resolveCollision(bombs[i], bombs[j]);
            }

            if (attachedPiece) {
                const half = currentBoardSize/2;
                if(attachedPiece.x < CX-half+attachedPiece.radius || attachedPiece.x > CX+half-attachedPiece.radius || 
                   attachedPiece.y < CY-half+attachedPiece.radius || attachedPiece.y > CY+half-attachedPiece.radius) isGameOver = true;
            }

            drawScene();
            requestAnimationFrame(gameLoop);
        }

        function drawScene() {
            ctx.fillStyle = "#111"; ctx.fillRect(0,0,CW,CH);
            const half = currentBoardSize / 2; const bX = CX - half; const bY = CY - half;
            ctx.fillStyle = "#d4a373"; ctx.fillRect(bX, bY, currentBoardSize, currentBoardSize);
            ctx.strokeStyle = "rgba(93, 62, 33, 0.4)"; ctx.lineWidth = 1; ctx.beginPath();
            const step = currentBoardSize/9;
            for(let i=1; i<9; i++) {
                ctx.moveTo(bX + i*step, bY); ctx.lineTo(bX + i*step, bY + currentBoardSize);
                ctx.moveTo(bX, bY + i*step); ctx.lineTo(bX + currentBoardSize, bY + i*step);
            }
            ctx.stroke();
            ctx.fillStyle = "rgba(255, 255, 200, 0.2)"; ctx.fillRect(bX, bY + currentBoardSize - SAFE_ZONE_SIZE, SAFE_ZONE_SIZE, SAFE_ZONE_SIZE);
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; ctx.font = "bold 16px sans-serif"; ctx.fillText("ÂÆâÁΩÆ", bX + 50, bY + currentBoardSize - 20);
            ctx.strokeStyle = "#5d3e21"; ctx.lineWidth = 8; ctx.strokeRect(bX, bY, currentBoardSize, currentBoardSize);
            pieces.forEach(p => p.draw()); bombs.forEach(b => b.draw());
            ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(mouseX, mouseY, 5, 0, Math.PI*2); ctx.fill();
            if (isGameOver || isClear) {
                if (!finalMsg) {
                    const msgs = isClear ? WIN_MSGS : LOSE_MSGS;
                    finalMsg = msgs[Math.floor(Math.random() * msgs.length)];
                }
                showOverlay(finalMsg.l1, finalMsg.l2, isClear ? "gold" : "#ff4400");
            }
        }

        function showOverlay(l1, l2, color) {
            ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,CW,CH);
            ctx.fillStyle = color; ctx.textAlign = "center";
            ctx.font = "bold 40px serif"; ctx.fillText(l1, CX, CY - 10);
            ctx.font = "bold 50px sans-serif"; ctx.fillText(l2, CX, CY + 50);
            ctx.fillStyle = "white"; ctx.font = "18px serif"; ctx.fillText("„ÇØ„É™„ÉÉ„ÇØ„ÅßÂÜçÊåëÊà¶", CX, CY + 100);
            ctx.font = "bold 24px monospace"; ctx.fillText(`TIME: ${elapsedTime}s`, CX, CY + 150);
            ctx.fillStyle = "#1DA1F2"; ctx.fillRect(CX - 80, CY + 180, 160, 40);
            ctx.fillStyle = "white"; ctx.font = "bold 16px sans-serif"; ctx.fillText("X„ÅßÁµêÊûú„ÇíÊäïÁ®ø", CX, CY + 205);
        }

        function tweetResult() {
            const text = encodeURIComponent(`ÈßíÂêà„Çè„Åõ by „ÅØ„Å™„Å≥ „Çí„ÇØ„É™„Ç¢ÔºÅ\n„Çø„Ç§„É†: ${elapsedTime}Áßí\n#ÈßíÂêà„Çè„Åõ #1Êó•1Êñ∞`);
            const url = `https://twitter.com/intent/tweet?text=${text}&url=${encodeURIComponent(window.location.href)}`;
            window.open(url, '_blank');
        }

        window.addEventListener('mousedown', (e) => {
            if (isGameOver || isClear) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
                if (mx > CX - 80 && mx < CX + 80 && my > CY + 180 && my < CY + 220) tweetResult();
                else { finalMsg = null; initGame(); }
                return;
            }
            if (!attachedPiece) {
                pieces.forEach(p => { if (Math.hypot(p.x - mouseX, p.y - mouseY) < p.radius * 2.5) {
                    attachedPiece = p; if(!startTime) startTime = Date.now();
                }});
            } else attachedPiece = null;
        });

        function initGame() {
            pieces = []; bombs = []; attachedPiece = null; isGameOver = false; isClear = false;
            speedMultiplier = 1.0; currentBoardSize = 560; startTime = null; timerEl.innerText = "00.00"; finalMsg = null; lastTime = Date.now();
            const bX = CX - 280; const bY = CY - 280;
            pieces.push(new Piece(bX + 50, bY + 510, 0, true)); pieces.push(new Piece(bX + 510, bY + 510, 0));
            for (let i = 1; i <= 6; i++) pieces.push(new Piece(CX + (Math.random()-0.5)*300, CY + (Math.random()-0.5)*200 - 50, i));
            requestAnimationFrame(gameLoop);
        }
        window.addEventListener('mousemove', e => { const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top; });
        initGame();
    </script>
</body>
</html>
